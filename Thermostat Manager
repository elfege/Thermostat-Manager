
definition(
    name: "Thermostat Manager",
    namespace: "elfege",
    author: "ELFEGE",

    description: "Smart Thermostat Manager (optional: contact sensors, motion sensors, power meter and safe redundancies)",

    category: "Green Living",
    iconUrl: "https://www.philonyc.com/assets/penrose.jpg",
    iconX2Url: "https://www.philonyc.com/assets/penrose.jpg",
    iconX3Url: "https://www.philonyc.com/assets/penrose.jpg", 
    image: "https://www.philonyc.com/assets/penrose.jpg"
)

preferences {

    page name: "settings"
    page name: "thermostats"
    page name: "methods"
    page name: "contactsensors"
    page name: "powersaving"

}
def settings() {

    pageNameUpdate()   

    def pageProperties = [
        name:       "settings",
        title:      "settings",
        nextPage:   null,
        install: true,
        uninstall: true
    ]

    dynamicPage(pageProperties) {

        section()
        {
            input "pause", "button", title: "$atomicState.button_name"
            input "restricted", "mode", title: "Restricted modes", multiple: true
        }

        section("Main Settings") {
            href "thermostats", title: "Thermostats and other devices", description: ""
            href "methods", title: "Methods of evaluation", description: ""
            href "contactsensors", title: "Contact sensors", description: ""
            href "powersaving", title: "Power Saving Options", description: ""

        }

        section() {
            label title: "Assign a name", required: false
        }

        section("Actions")
        {
            input "run", "button", title: "RUN"
            input "update", "button", title: "UPDATE"
            input "poll", "button", title: "REFRESH SENSORS"
            input "polldevices", "bool", title: "Poll devices"
            input "enabledebug", "bool", title: "Debug", submitOnChange:true
            if(enabledebug)
            {
                log.warn "debug enabled"      
                atomicState.EnableDebugTime = now()
                runIn(1800,disablelogging)
                descriptiontext "debug will be disabled in 30 minutes"
            }
            else 
            {
                log.warn "debug disabled"
            }
            input "description", "bool", title: "Description Text", submitOnChange:true

        }
    }
}
def thermostats(){

    def title = formatTitle("Thermostats, sensors, heaters and coolers", "white", "grey")

    def pageProperties = [
        name:       "thermostats",
        title:      title,
        nextPage:   "settings",
        install: false,
        uninstall: false
    ]

    dynamicPage(pageProperties) {
        section("Select the thermostat you want to control")
        { 
            input "thermostat", "capability.thermostat", title: "select a thermostat", required: true, multiple: false, description: null, submitOnChange:true
            input "pw", "capability.powerMeter", title:"verify status with a power meter", required:false
            input "heatpump", "bool", title: "$thermostat is a heat pump", submitOnChange:true
        }

        section("Sensors")
        {
            input "outsideTemp", "capability.temperatureMeasurement", title: "Required: select a weather sensor for outside temperature", required:true, submitOnChange:true
            input "sensor", "capability.temperatureMeasurement", title: "select a temperature sensor (optional)", submitOnChange:true, multiple:true
            if(sensor)
            {
                input "offrequiredbyuser", "bool", title: "turn off thermostat when desired temperature has been reached", defaultValue: false, submitOnChange:true
            }
        }

        section("Select alternate heater and/or cooler")
        {
            input "heater", "capability.switch", title: "Select a switch to control an alternate heater", required: true, submitOnChange:true, multiple: false 
            if(!heatpump)
            {
                input "addLowTemp", "bool", title: "Use only if temperature goes down below a certain threshold", submitOnChange:true   
            }
            if(heatpump || addLowTemp)
            {
                input "lowtemp", "number", title: "low temperature threshold", required: true, defaultValue: 30
            }

            input "cooler", "capability.switch", title: "Select a switch to control an alternate cooler", required: false, submitOnChange:true, multiple: false 

        }

        section("Central Thermostat")
        {

            if(thermostat){
                paragraph formatTitle("Make $thermostat a central thermostat for your home", "white", "blue")
                input "sync", "bool", title:"Synchronize ${thermostat} with states from a different thermostat", defaultValue:false, submitOnChange:true
                if(sync)
                {
                    input "thermostatB", "capability.thermostat", title: "select a second thermostat", required: true, multiple: true, description: null, submitOnChange:true
                    input "ignoreTherModes", "bool", title: "Ignore operating modes, synchronize set points only", defaultValue: false
                }
            }
        }
    }
}
def methods(){

    def title = formatTitle("METHODS OF EVALUTATION:", "white", "grey")

    def pageProperties = [
        name:       "methods",
        title:      title,
        nextPage:   "settings",
        install: false,
        uninstall: false
    ]

    dynamicPage(pageProperties) {

        section(){

            input "method", "enum", title:"select the method you want $app.name to use to adjust your thermostats cooling and heating set points", options:["dimmer","auto"],submitOnChange:true

            if(method == "dimmer")
            {
                input "dimmer", "capability.switchLevel", title: "Use this dimmer as set point input source", required: true, submitOnChange:true
            }
            else if(method == "auto")
            {
                input "refTemp", "number", title: "Set an outside temperature reference for which you will set (below) a desired variation (for example: 77)", required: false, range: "30..100", submitOnChange:true
                input "desiredVar", "number", title: "Set an desired variation: by how much you want inside temperature to differ from outside temp?", required:false, range: "1..20", submitOnChange:true
                if(refTemp && desiredVar)
                {
                    paragraph """EXAMPLES: 
with an outside temp of 77F your room will be cooled to ${77 - desiredVar}F 
if outside temperature is, let's say 45F, then slope of this linear function will be reversed so to heat your room at arround 72F """
                }
                input "maxAutoHeat", "number", title: "Maximum heating temperature", defaultValue: 75
                input "minAutoCool", "number", title: "Minimum cooling temperature", defaultValue: 70
            }
        }
    }
}
def contactsensors(){

    def title = formatTitle("CONTACTS AND DOORS", "white", "grey")

    def pageProperties = [
        name:       "contactsensors",
        title:      title,
        nextPage:   "settings",
        install: false,
        uninstall: false
    ]

    dynamicPage(pageProperties) {

        section()
        {
            input "contact", "capability.contactSensor", title: "Turn off everything when these contacts are open", multiple: true, required: false, submitOnChange:true

            input "useAbedSensor", "bool", title: "Use a bed sensor", submitOnChange:true
            if(useAbedSensor)
            {
                def message = ""

                input "bedSensorType", "enum", title: "Which type ?", options: ["contact", "button"], submitOnChange:true, required:true
                if(bedSensorType == "contact")
                {
                    def s = bedSensorContact?.size() 
                    def i = 0
                    input "bedSensorContact", "capability.contactSensor", title: "When ${!bedSensorContact ? "this contact is" : (s > 1 ? "these contacts are" : "this contacts is")} closed, operate in limited mode", multiple: true, required: false, submitOnChange:true
                    def devivesStr = ""
                    for(s!=0;i<s;i++){
                        devivesStr = devivesStr.length() > 0 ? devivesStr + ", " + bedSensorContact[i].toString() : bedSensorContact[i].toString()
                    } 
                    message = bedSensorContact ? "$app.label will work in limited mode when $devivesStr ${s > 1 ? "are" : "is"} closed and/or ${s > 1 ? "have" : "has"} been closed within 1 minute. Power saving options will not be active" : ""

                }
                else if(bedSensorType == "button")
                {
                    def s = bedSensorButton?.size() 
                    def i = 0
                    input "bedSensorButton", "capability.releasableButton", title: "When ${!bedSensorButton ? "this button is" : (s > 1 ? "these buttons are" : "this button is")} held or pushed, work in limited mode", multiple: true, required: false, submitOnChange:true
                    def devivesStr = ""
                    for(s!=0;i<s;i++){
                        devivesStr = devivesStr.length() > 0 ? devivesStr + ", " + bedSensorButton[i].toString() : bedSensorButton[i].toString()
                    } 
                    message = bedSensorButton ? "$app.label will operate in limited mode when $devivesStr ${s > 1 ? "have" : "has"} been pushed or held within 1 minute. Power saving options will not be active" : ""
                }
                paragraph "<div style=\"width:102%;background-color:grey;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">${message}</div>"
                def bedDevice = bedSensorType == "contact" ? bedSensorContact : bedSensorButton
                input "setSpecialTemp", "bool", title: "Keep room at a preset temperature when in $bedDevice is ${bedSensorType == "contact" ? "closed" : "pushed or held"}", submitOnChange:true, defaultValue:false

                if(setSpecialTemp)
                {
                    input "specialTemp", "number", title: "Set the desired temperature", required: true
                }
            }
            input "doorsManagement", "bool", title: "When some doors are open, synchronise $thermostat with a thermostat from another room", defaultValue:false, submitOnChange:true
            if(doorsManagement)
            {
                input "doorsContacts", "capability.contactSensor", title: "select contact sensors", required:true, multiple:true, submitOnChange:true

                input "doorThermostat", "capability.thermostat", title: "select a thermostat from a different room", required:true, submitOnChange:true
                paragraph: "when ${doorsContacts.size()>1?"any of":""} $doorsContacts ${doorsContacts.size()>1?"are":"is"} open, $thermostat will synchornise with $doorThermostat " 
                if(useAbedSensor)
                {
                    input "overrideSimpleMode", "bool", title: "This option overrides Bed Sensor"
                }
                if(doorsContacts)
                {
                    input "useDifferentSetOfSensors", "bool", title: "Use a different set of sensors when ${doorsContacts} ${doorsContacts.size()>1?"are":"is"} open", submitOnChange:true
                    if(useDifferentSetOfSensors)
                    {
                        input "doorSetOfSensors", "capability.temperatureMeasurement", title: "Select your sensors", multiple:true, submitOnChange:true, required:true
                    }
                }
            }
        }
    }
}
def powersaving(){

    def title = formatTitle("POWER SAVING OPTIONS","white", "grey")

    def pageProperties = [
        name:       "powersaving",
        title:      title,
        nextPage:   "settings",
        install: false,
        uninstall: false
    ]

    dynamicPage(pageProperties) {

        section("Motion Management")
        {
            input "motionSensors", "capability.motionSensor", title: "Save power when there's no motion", required: false, multiple: true, submitOnChange:true

            if(motionSensors)
            {
                input "noMotionTime", "number", title: "after how long?", description: "Time in minutes"
                input "motionmodes", "mode", title: "Consider motion only in these modes", multiple: true, required: true 
            }  

            input "powersavingmode", "mode", title: "Save power when in one of these modes", required: false, multiple: true, submitOnChange: true
            if(powersavingmode)
            {
                input "criticalcold", "number", title: "Set a critical low temperature", required: true
                input "criticalhot", "number", title: "Set a critical high temperature", required: true
            }
        }

        section("Fans or Windows")
        {
            input "controlWindows", "bool", title: "Control some windows", submitOnChange:true
            if(controlWindows)
            {
                input "windows", "capability.switch", title: "Turn on those switches when home needs to cool down, wheather permitting", multiple:true, required: false, submitOnChange: true
                if(windows)
                {
                    input "windowsModes", "mode", title: "Select under which modes $windows can be operated", required:true, multiple:true

                    input "outsidetempwindowsH", "number", title: "Set a temperature below which it's ok to turn on $windows", required: true, submitOnChange: true
                    input "outsidetempwindowsL", "number", title: "Set a temperature below which it's NOT ok to turn on $windows", required: true, submitOnChange: true
                    if(outsidetempwindowsH && outsidetempwindowsL)
                    {
                        paragraph "If outside temperature is between ${outsidetempwindowsL}F & ${outsidetempwindowsH}F, $windows will be used to coold down your place instead of your AC"

                        input "operationTime", "bool", title: "${windows}' operation must stop after a certain time", defaultValue:false, submitOnChange:true
                        if(operationTime)
                        {
                            input "windowsDuration", "number", title: "Set minimum operation time", description: "time in seconds", required: false, submitOnChange:true
                            if(windowsDuration)
                            {
                                paragraph "<div style=\"width:102%;background-color:#1C2BB7;color:red;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">${app.name} will determine duration based on this value and outside temperature. The cooler it is outside, the shorter the duration (the closer the duration will be to the minimum you set here). Recommended value: 10 seconds</div>"
                            }
                            input "maxDuration", "number", title: "Set maximum operation time", description: "time in seconds", required: false, submitOnChange:true

                            input "customCommand", "text", title: "custom command to stop operation (default is 'off()')", required: false, submitOnChange:true

                            if(customCommand)
                            {
                                def cmd = customCommand.contains("()") ? customCommand.minus("()") : customCommand
                                def windowsCmds = windows.findAll{it.hasCommand("${cmd}")}
                                boolean cmdOk = windowsCmds.size() == windows.size()
                                if(!cmdOk)
                                {
                                    paragraph "<div style=\"width:102%;background-color:#1C2BB7;color:red;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">SORRY, THIS COMMAND $customCommand IS NOT SUPPORTED BY AT LEAST ONE OF YOUR DEVICES! Maybe a spelling error? In any case, make sure that each one of them support this command</div>"

                                }
                                else
                                {
                                    paragraph """<div style=\"width:102%;background-color:grey;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">The command $customCommand is supported by all your devices!</div> """

                                }
                            }

                        }
                    }
                }
            }
        }
    }
}

def pageNameUpdate(){
    if(atomicState.paused)
    {
        log.debug "new app label: ${app.label}"
        while(app.label.contains(" (Paused) "))
        {
            app.updateLabel(app.label.minus("(Paused)" ))
        }
        app.updateLabel(app.label + ("<font color = 'red'> (Paused) </font>" ))
    }
    else if(app.label.contains("(Paused)"))
    {
        app.updateLabel(app.label.minus("<font color = 'red'> (Paused) </font>" ))
        while(app.label.contains(" (Paused) ")){app.updateLabel(app.label.minus("(Paused)" ))}
        log.debug "new app label: ${app.label}"
    }
    if(atomicState.paused == true)
    {
        atomicState.button_name = "resume"
        log.debug "button name is: $atomicState.button_name"
    }
    else 
    {
        atomicState.button_name = "pause"
        log.debug "button name is: $atomicState.button_name"
    }
}

def installed() {
    logging("Installed with settings: ${settings}")

    initialize()
}
def updated() {

    log.info "${app.name} updated with settings: $settings"

    unsubscribe()
    unschedule()
    initialize()
}
def initialize(){

    if(enabledebug)
    {
        log.warn "debug enabled"      
        atomicState.EnableDebugTime = now()
        runIn(1800,disablelogging)
        descriptiontext "debug will be disabled in 30 minutes"
    }
    else 
    {
        log.warn "debug disabled"
    }
    atomicState.paused = false
    atomicState.restricted = false
    atomicState.lastNeed = "cool"


    atomicState.setpointSentByApp = false
    atomicState.openByApp = true
    atomicState.closedByApp = true

    atomicState.resendAttempt = now() as long
        atomicState.offAttempt = now() as long

        atomicState.lastMotionEvent = now() as long
        atomicState.motionEvents = 0

    logging("subscribing to events...")

    //subscribe(location, "mode", ChangedModeHandler) 
    subscribe(thermostat, "temperature", temperatureHandler)
    if(sensor)
    {
        int i = 0
        int s = sensor.size()
        for(s != 0; i<s;i++)
        {
            subscribe(sensor[i], "temperature", temperatureHandler)
        }
    }
    if(dimmer)
    {
        subscribe(dimmer, "level", dimmerHandler)
    }
    descriptiontext "subscribed $dimmer to dimmerHandler"
    subscribe(thermostat, "heatingSetpoint", setPointHandler)
    subscribe(thermostat, "coolingSetpoint", setPointHandler)
    subscribe(thermostat, "thermostatMode", thermostatModeHandler)
    
    descriptiontext "subscribed ${thermostat}'s coolingSetpoint to setPointHandler"
    descriptiontext "subscribed ${thermostat}'s heatingSetpoint to setPointHandler"
    descriptiontext "subscribed ${thermostat}'s thermostatMode to thermostatModeHandler"

    if(sync && thermostatB)
    {
        int i = 0
        int s = thermostatB.size()
        for(s!= 0; i<s; i++)
        {
            subscribe(thermostatB[i], "heatingSetpoint", setPointHandler)
            subscribe(thermostatB[i], "coolingSetpoint", setPointHandler)
            subscribe(thermostatB[i], "thermostatMode", thermostatModeHandler)
            descriptiontext "subscribed ${thermostatB[i]}'s thermostatMode to thermostatModeHandler"
            descriptiontext "subscribed ${thermostatB[i]}'s heatingSetpoint to setPointHandler"
            descriptiontext "subscribed ${thermostatB[i]}'s coolingSetpoint to setPointHandler"
        }
    }    

    subscribe(location, "mode", modeChangeHandler)

    if(bedSensorContact)
    {        
        subscribe(bedSensorContact, "contact", contactHandler)
    }
    if(bedSensorButton)
    {
        subscribe(bedSensorButton, "held", holdableButtonHandler)   
        subscribe(bedSensorButton, "pushed", holdableButtonHandler)   
    }
    if(contact)
    {
        subscribe(contact, "contact", contactHandler)
    }
    if(motionSensors)
    {
        subscribe(motion, "motion", motionHandler)
    }

    if(polldevices)
    {
        schedule("0 0/5 * * * ?", Poll)
    }

    schedule("0 0/1 * * * ?", mainloop)


    descriptiontext "END OF INITIALIZATION"

}
/************************************************EVT HANDLERS*********************************************************/
def modeChangeHandler(evt){
    log.debug "$evt.name is now $evt.value"
    atomicState.openByApp = true
    atomicState.closedByApp = true  

    if(evt.value in restricted)
    {
        atomicState.paused = true   
        atomicState.restricted = true
    }
    else if(atomicState.paused == true && atomicState.restricted == true)
    {
        updated()
    }
    mainloop()
}
def appButtonHandler(btn) {
    switch(btn) {
        case "pause":atomicState.paused = !atomicState.paused
        logging("atomicState.paused = $atomicState.paused")
        if(atomicState.paused)
        {
            log.debug "unsuscribing from events..."
            unsubscribe()  
            log.debug "unschedule()..."
            unschedule()
            break
        }
        else
        {
            updated()            
            break
        }
        case "update":
        atomicState.paused = false
        updated()
        break
        case "run":
        if(!atomicState.paused) mainloop()
        break
        case "poll":
        Poll()
        break

    }
}
def contactHandler(evt){
    log.info "$evt.device is $evt.value"
    mainloop()
}
def motionHandler(evt){

    logging("$evt.device is $evt.value")

    if(evt.value == "active")
    {
        mainloop()
    }

}
def temperatureHandler(evt){
    logging("$evt.device returns ${evt.value}F")
    mainloop()
}
def holdableButtonHandler(evt){
    log.debug "$evt.device $evt.name $evt.value"
}
def thermostatModeHandler(evt){
    
   logging """$evt.device $evt.name $evt.value
sync ? $sync
thermostatB: $thermostatB

"""
    if(sync && thermostatB)
    {
        int i = 0
        int s = thermostatB.size()

        if(!ignoreTherModes)
        {
            if("$evt.device" == "$thermostat")
            {
                //log.warn "case AM"
                def cmd = "set${evt.name.capitalize()}"
                for(s!=0; i<s; i++)
                {
                    thermostatB[i]."${cmd}"(evt.value)
                    descriptiontext "$thermostatB[i] $cmd $evt.value"
                }
            }
            else if(thermostatB.find{it.toString() == "$evt.device"})
            {
                //log.warn "case BM"
                def cmd = "set${evt.name.capitalize()}"
                thermostat."${cmd}"(evt.value)
                descriptiontext "$thermostat $cmd $evt.value"
            }
        }
        else
        {
            descriptiontext "ignoring operating mode sync at user request (syncing set points only)"
        }
    }
}
def setPointHandler(evt){

    log.warn """$evt.device $evt.name $evt.value
sync ? $sync
thermostatB: $thermostatB

"""

    if(sync && thermostatB)
    {
        def cmd = "set${evt.name.capitalize()}"
        int i = 0
        int s = thermostatB.size()
        
        
        logging """
thermostat = $evt.device
evt.value = $evt.value
evt.name = $evt.name
${thermostat?.currentValue(evt.name) != "$evt.value"}

KEEP FOR FUTURE REFERENCE!
thermostatB current set point: ${thermostatB[0].currentValue(evt.name)} = $evt.value
true? ${thermostatB[0].currentValue(evt.name) == evt.value.toInteger()}
any found with same current value: ${thermostatB?.any{it -> it.currentValue(evt.name) == evt.value.toInteger()}} 


"""

        if("$evt.device" == "$thermostat")
        {
            log.warn "case ASP"
            for(s!=0; i<s; i++)
            {
                thermostatB[i]."${cmd}"(evt.value)
                descriptiontext "$thermostatB[i] $cmd $evt.value"
            }
        }
        if(thermostatB.find{it.toString() == "$evt.device"})
        {
            log.warn "case BSP"
            thermostat."${cmd}"(evt.value)
            descriptiontext "$thermostat $cmd $evt.value"
            //atomicState.setpointSentByApp = true
        }
        //return // must not set atomicState.setpointSentByApp back to false in this case
    }
    if(!atomicState.setpointSentByApp)
    {
        descriptiontext "new $evt.name is $evt.value---------------------------------------"

        def currDim = dimmer?.currentValue("level")
        def thermMode = thermostat?.currentValue("thermostatMode")

        // this will be true only if thermostat is heating or cooling; therefore, dimmer won't be adjusted if off 
        // using atomicState.lastNeed == "heat" / "cool" seemed to allow exceptions... 
        boolean correspondingMode = (evt.name == "heatingSetpoint" && thermMode == "heat") || (evt.name == "coolingSetpoint" && thermMode == "cool")

        def message = """
atomicState.setpointSentByApp = $atomicState.setpointSentByApp
Current $dimmer value is $currDim
atomicState.lastNeed = $atomicState.lastNeed   
evt.value = $evt.value   
"""
        logging "<div style=\"width:102%;background-color:grey;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">$message</div>"

        boolean bedsensorclosed = bedSensorIsClosed()
        def desired = getDesired(bedsensorclosed)
        def inside = atomicState.inside != null ? atomicState.inside : getInsideTemp()
        def needData = getNeed(desired, bedsensorclosed, inside)
        def need = needData[1]
        def cmd = "set"+"${needData[0]}"+"ingSetpoint" // "Cool" or "Heat" with a capital letter


        // make sure the therm event is same as current need
        // as to not apply a value from a differentiated thermostat mode (heat set to 75 will modify coolingSP and then trigger an event)

        if(correspondingMode && currDim != evt.value) 
        {
            if(method == "dimmer")
            {
                //runIn(3, setDimmer, [data:evt.value.toInteger()]) 
                setDimmer(evt.value.toInteger())
            }
        }
        if(!correspondingMode)
        {
            descriptiontext "not updating dimmer because this is $evt.name and current mode is $thermMode"
        }
        if(currDim == evt.value)
        {
            descriptiontext "dimmer level ok (${dimmer?.currentValue("level")} == ${evt.value}"
        }
    }
    else
    {
        log.warn "event generated by this app, doing nothing"
    }
    atomicState.setpointSentByApp = false // always reset this static/class variable after calling it
    //mainloop() // prevent feedback loops so both dimmer and thermosta set points can be modified. Changes will be made on next scheduled loop or motion events
}
def dimmerHandler(evt){
    descriptiontext "new dimmer level is $evt.value"
    //mainloop() // prevent feedback loops so both dimmer and thermosta set points can be modified. Changes will be made on next scheduled loop or motion events
}
def outsideThresDimmerHandler(evt){
    descriptiontext "*********** Outside threshold value is now: $evt.value ***********"
    //mainloop()
}
/************************************************MAIN functions*************************************************/
def mainloop(){

    if(!atomicState.paused)
    {
        boolean bedsensorclosed = bedSensorIsClosed()
        int desired = getDesired(bedsensorclosed)
        def inside = getInsideTemp()
        def needData = getNeed(desired, bedsensorclosed, inside)
        def need = needData[1]

        def currSP = thermostat?.currentValue("thermostatSetpoint").toInteger()
        //log.warn "--- $currSP"
        def thermMode = thermostat?.currentValue("thermostatMode")
        logging("need is needData[1] = $need")
        def cmd = "set"+"${needData[0]}"+"ingSetpoint" // "Cool" or "Heat" with a capital letter

        if(thermMOde == "auto")
        {
            log.info "OVERRIDE"
            return
        }


        if(enabledebug && now() - atomicState.EnableDebugTime > 1800000)
        {
            descriptiontext "Debug has been up for too long..."
            disablelogging() 
        }

        def therMode = thermostat?.currentValue("thermostatMode")
        logging("$thermostat is in $therMode mode 54dfg")

        if(pw)
        {
            logging("$pw power meter returns ${pw?.currentValue("power")}Watts")
        }
        if(therMode != "auto")
        {

            logging"""
therMode = $therMode currSP = $currSP"
currSP != desired -> ${currSP != desired} -> ${currSP} != ${desired} 
"""

            virtualThermostat(need)


            if(therMode != need)
            {
                if(need != "off" || (need == "off" && (sensor || offrequiredbyuser)))
                {
                    thermostat.setThermostatMode(need) // set desired mode
                    logging("THERMOSTAT SET TO $need mode (587gf)")
                    if(need == "off")
                    {
                        atomicState.offAttempt = now() as long
                            }
                }
                else 
                {
                    logging("THERMOSTAT stays in $therMode mode")
                }

            }
            else if(need != "off")
            {
                logging("Thermostat already set to $need mode")
            }

            if(need != "off" && currSP.toInteger() != desired)
            {
                atomicState.setpointSentByApp = true
                thermostat."${cmd}"(desired)   // set desired temp
                logging("THERMOSTAT SET TO $desired (564fdevrt)")
            }
            else if(need != "off")
            {
                logging("Thermostat already set to $desired")
            }

            if(pw)
            {
                atomicState.resendAttempt = atomicState.resendAttempt ? atomicState.resendAttempt : now()
                atomicState.offAttempt = atomicState.offAttempt ? atomicState.offAttempt : now()
                // here we manage possible failure for a thermostat to have received the z-wave/zigbee or http command
                long timeElapsedSinceLastResend = now() - atomicState.resendAttempt
                long timeElapsedSinceLastOff = now() - atomicState.offAttempt // when device driver returns state off while in fact signal didn't go through
                long threshold = 4 * 60 * 1000 // give it 4 minutes to kick in before attempting new request 
                boolean timeIsUp = timeElapsedSinceLastResend > threshold
                boolean timeIsUpOff = timeElapsedSinceLastOff > 30000
                boolean pwLow = pw?.currentValue("power") < 100 // below 100 watts we assume there's no AC compression nor resistor heat running
                logging("time since last Resend Attempt = ${timeElapsedSinceLastResend/1000} seconds & threshold = ${threshold/1000}sec")
                logging("time since last OFF Attempt = ${timeElapsedSinceLastOff/1000} seconds & threshold = ${30}sec")

                if(timeIsUp && pwLow && need != "off")
                {
                    descriptiontext "$app.label is resending ${cmd}(${desired}) due to inconsistency in power value"
                    atomicState.resendAttempt = now() as long
                        atomicState.setpointSentByApp = true
                    thermostat."${cmd}"(desired) // resend cmd
                }
                else if(timeIsUpOff && need == "off" && !pwLow && !doorsContactsAreOpen())
                {
                    log.warn("$thermostat should be off but still draining power, resending cmd")
                    atomicState.offAttempt = now() as long
                        thermostat.setThermostatMode("off")
                    thermostat.off()
                }
                else if((!pwLow &&  need in ["heat", "cool"]) || (need == "off" && pwLow))
                {
                    logging("EVERYTHING OK")
                }
                else 
                {
                    logging("Auto Fix Should Kick in within time threshold")
                }
            }
        }
        else 
        {
            descriptiontext("OVERRIDE MODE--------------")   
        }
    }
}
def setDimmer(int val){
    atomicState.setpointSentByApp = true
    dimmer.setLevel(val) // reverse definition 
    descriptiontext "$dimmer set to $val BY THIS APP"
}
def virtualThermostat(need){
    if(heatpump || addLowTemp)
    {
        def outsideTemperature = outsideTemp?.currentValue("temperature") // only needed if electric heater here
        def lowTemperature = lowtemp ? lowtemp : 40
        logging("outsideTemperature < lowTemperature ? ${outsideTemperature < lowTemperature}")
        if(need == "heat" && outsideTemperature < lowTemperature.toInteger())
        {
            boolean powercap = heater.hasAttribute("power")
            logging("is heater power meter capable? $powercap")
            boolean powerok = powercap ? (heater?.currentValue("power") > 100) : true
            logging "$heater power consumption is ${powerok ? "ok" : "not as expected"} ${powercap ? "${heater?.currentValue("power")}watts" : ''}"
            if(heater?.currentValue("switch") != "on" || !powerok)
            {
                logging("Turning $heater on because outside temperature is currently ${outsideTemperature}°F")
                heater.on()   
            }
            else 
            {
                logging("$heater is on because outside temperature is currently ${outsideTemperature}°F")
            }
        }
        else 
        {
            if(heater?.currentValue("switch") != "off")
            {
                logging("Turning $heater off")
                heater.off()
            }
            else 
            {

                logging("$heater already off")
            }
        }
    }
    if(cooler)
    {
        if(need == "cool"){
            logging "turning $cooler on"
            cooler.on()
        }
        else {
            logging "turning $cooler off"
            cooler.off()
        }
    }
}
/************************************************DECISIONS*********************************************************/
def getDesired(bedsensorclosed){
    int desired = 70

    if(bedsensorclosed && setSpecialTemp)
    {
        if(doorsContactsAreOpen() && overrideSimpleMode)
        {
            descriptiontext "some doors are open and this overrides bed sensor mode at user's request"
        }
        else 
        {            
            desired = specialTemp
            return desired // END due to bed sensor mode
        }
    } 

    if(method == "auto")
    {
        desired = getAutoVal()
    }
    else
    {
        desired = dimmer?.currentValue("level")
    }
    descriptiontext "desired temperature is: $desired and current temperature is ${atomicState.inside}"
    return desired
}
def getAutoVal(){

    def result = 73 // just a temporary default value
    def outside = outsideTemp?.currentValue("temperature")
    def humidity = outsideTemp?.currentValue("humidity") // outside humidity
    def insideHum = thermostat?.currentValue("humidity") // backup value if outside sensor fails to return value (when just configured, for example)
    humidity = humidity != null ? humidity : (insideHum != null ? insideHum : 50) // 50 is a temporary value when both devices have just been installed by user and hum value is yet to be parsed
    def humThres = getHumidityThreshold() // linear equation: hum thres varies with outside temp
    def need = atomicState.lastNeed != null ? atomicState.lastNeed : (outside >= getOutsideThershold() ? "cool" : "heat")
    def variation = getVariationAmplitude(outside, need)

    result = need == "cool" ? (humidity >= humThres ? outside - (variation+1) : outside - variation) : (need == "heat" ? (humidity >= humThres ? outside + (variation+1) : outside + variation) : "ERROR")

    if(result == "ERROR") { 
        log.warn """ERROR at getAutoVal()
need = $need
atomicState.lastNeed = $atomicState.lastNeed
humidity = $humidity
insideHum = $insideHum
humThres = $humThres
outside = $outside
""" 
        return 73
    }

    result = result > maxAutoHeat ? maxAutoHeat : result
    result = result < minAutoCool ? minAutoCool : result 

    descriptiontext "desired temperature (auto) in this room is: $result (${humidity > humThres ? "humid condition true" : "humid condition false"} outside: $outside) "
    return result
}
def getVariationAmplitude(outside, need){

    def max = 10 // max variation

    def y = null // value to find
    def x = outside // current temperature outside
    def ya = desiredVar != null ? desiredVar : 1 // coressponding difference required when outside temperature = xa
    def xa = refTemp != null ? refTemp : 77 // 
    def slope = 0.8
    def m = need == "cool" ? slope : (slope + 0.1)*-1  // slope 
    //def a = -1 // offset

    y = m*(x-xa)+ya // solving y-ya = m*(x-xa)
    y = y < max ? y : max
    y = y < 0 ? 0 : y

    log.warn "linear result for amplitude variation for auto temp = ${y.toInteger()}"
    return y.toInteger()

}
def getNeed(desired, bedSensorContactClosed, inside){

    def humidity = outsideTemp?.currentValue("humidity") 
    def insideHum = thermostat?.currentValue("humidity") // backup for windows and value used for negative swing variation when cooling
    humidity = humidity != null ? humidity : (insideHum != null ? insideHum : 50)
    boolean INpwSavingMode = powersavingmode && location.mode in powersavingmode && !bedSensorContactClosed 
    boolean inWindowsModes = windows && location.mode in windowsModes
    boolean contactClosed = !contactsAreOpen()  
    def outsideThres = getOutsideThershold()
    int outsideTemperature = outsideTemp?.currentValue("temperature")
    def need0 = ""
    def need1 = ""
    def need = []
    def amplThreshold = 4
    def amplitude = Math.abs(inside - desired)
    def swing = 0.5
    def coolswing = insideHum < 60 ? desired + swing : desired - swing // if too humid, swing down the threshold when cooling
    boolean amplitudeTooHigh = amplitude >= amplThreshold // amplitude between inside temp and desired / preventing amplitude paradox during mid-season
    boolean needCool = !bedSensorContactClosed || inWindowsModes ? ((outsideTemperature >= outsideThres || amplitudeTooHigh) && inside >= coolswing) : inside >= desired + swing
    boolean needHeat = !bedSensorContactClosed ? ((outsideTemperature < outsideThres || amplitudeTooHigh) && inside <= desired - swing) : (inside <= desired - swing && outsideTemperature < outsideThres)
    boolean motionActive = Active() || bedSensorContactClosed

    if(doorsManagement && doorsContactsAreOpen())
    {
        def n = doorThermostat?.currentValue("thermostatMode")
        need0 = n.capitalize() // capital letter for later construction of the setCoolingSetpoint cmd
        need1 = n
        def message = "$doorsContacts ${doorsContacts.size() > 1 ? "are":"is"} open. $thermostat set to ${doorThermostat}'s mode ($n)"
        descriptiontext "<div style=\"width:102%;background-color:grey;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">$message</div>"  


    }
    else if(!INpwSavingMode && contactClosed && motionActive)
    {
        if(needCool || needHeat)
        {
            if(needCool)
            {
                need0 = "Cool"// capital letter for later construction of the setCoolingSetpoint cmd
                need1 = "cool"
                atomicState.lastNeed = need1
                logging("need and atomicState.lastNeed respectively set to ${[need0,need1]}")
            }
            if(needHeat) // heating need supercedes cooling need in order to prevent amplitude paradox
            {
                need0 = "Heat" // capital letter for later construction of the setHeatingSetpoint cmd
                need1 = "heat"
                atomicState.lastNeed = need1
                logging("need and atomicState.lastNeed respectively set to ${[need0,need1]}")
            }
        }
        else
        {
            need0 = "off"
            need1 = "off"
            logging("need set to OFF")
        }
    }
    else   // POWER SAVING MODE OR NO MOTION OR CONTACTS OPEN     
    { 

        def cause = !motionActive ? "no motion" : (INpwSavingMode ? "power saving mode" : (!contactClosed ? "Contacts Open" : "UNKNOWN CAUSE - SPANK DEVELOPPER"))

        logging """
inside < criticalhot :  ${inside < criticalhot}
inside > criticalcold :  ${inside > criticalcold}

"""        

        need0 = "off"
        need1 = "off"

        if(inside > criticalhot)
        {
            log.warn """<div style=\"width:102%;background-color:red;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">POWER SAVING MODE EXPCETION: TOO HOT! ($cause)</div>"""
            need0 = "Cool"
            need1 = "cool"
        }
        else if(inside < criticalcold)
        {
            """<div style=\"width:102%;background-color:blue;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">POWER SAVING MODE EXPCETION: TOO COLD! ($cause)</div>"""
            need0 = "Heat"
            need1 = "heat"
        }
    }


    if(windows && !bedSensorContactClosed && thermostat?.currentValue("thermostatMode") != "auto")
    {

        def humThres = getHumidityThreshold() // linear equation: hum thres varies with outside temp
        boolean tooHumid = humThres < 80 ? humidity >= humThres : true
        boolean contactCapable = windows.any{it -> it.hasCapability("contact")}//?.size() == windows.size() 
        boolean someAreOff =  contactCapable ? (windows.findAll{it?.currentValue("contact") == "closed"}?.size() > 0) : (windows.findAll{it?.currentValue("switch") == "off"}?.size() > 0)
        boolean someAreOpen = contactCapable ? (windows.findAll{it?.currentValue("contact") == "open"}?.size() > 0) : (windows.findAll{it?.currentValue("switch") == "on"}?.size() > 0)
        boolean withinRange = outsideTemperature < outsidetempwindowsH && outsideTemperature > outsidetempwindowsL // stric temp value
        boolean outsideWithinRange = withinRange && !tooHumid // same as withinRange but not too humid 

        atomicState.lastOpeningTime = atomicState.lastOpeningTime ? atomicState.lastOpeningTime : (atomicState.lastOpeningTime = now()) // make sure value is not null
        atomicState.outsideTempAtTimeOfOpening = atomicState.outsideTempAtTimeOfOpening ? atomicState.outsideTempAtTimeOfOpening : outsideTemperature // make sure value is not null
        boolean outsideTempHasDecreased = outsideTemperature < atomicState.outsideTempAtTimeOfOpening - swing // serves mostly to reset opening time stamp
        atomicState.lastOpeningTime = outsideTempHasDecreased ? (atomicState.lastOpeningTime = now()) : atomicState.lastOpeningTime // reset opening time stamp if cooler outside

        atomicState.insideTempAtTimeOfOpening = atomicState.insideTempAtTimeOfOpening ? atomicState.insideTempAtTimeOfOpening : inside // make sure value is not null
        boolean insideTempHasIncreased = inside > atomicState.insideTempAtTimeOfOpening + swing // serves for windows wider opening ONLY
        atomicState.widerOpeningDone = (atomicState.widerOpeningDone != null) ? atomicState.widerOpeningDone : (atomicState.widerOpeningDone = false) // make sure value is not null
        boolean openMore = !atomicState.widerOpeningDone && insideTempHasIncreased && someAreOpen

        boolean insideTempIsHopeLess = inside > atomicState.insideTempAtTimeOfOpening + 2 && atomicState.widerOpeningDone

        double lastOpeningTime = (now() - atomicState.lastOpeningTime) / 1000 / 60 
        lastOpeningTime = lastOpeningTime.round(2)
        boolean openSinceLong = lastOpeningTime > 15.0 && someAreOpen // been open for more than 15 minutes

        atomicState.lastClosingTime = atomicState.lastClosingTime ? atomicState.lastClosingTime : (atomicState.lastClosingTime = now()) // make sure value is not null
        double lastClosingTime = (now() - atomicState.lastClosingTime) / 1000 / 60 
        lastClosingTime = lastClosingTime.round(2)
        boolean closedSinceLong = lastClosingTime > 10.0 && someAreClosed // been open for more than 30 minutes
        boolean tooColdInside = inside <= desired - 4
        //closing error management for safety, if cmd didn't go through for whatever reason and temp went too low, force close the windows
        boolean exception = someAreOpen && ((atomicState.closedByApp && now() - lastClosingTime > 30 && tooColdInside) || (!outsideWithinRange && tooColdInside))
        long elapsed = now() - lastClosingTime
        def elapsedseconds = elapsed/1000
        def elapsedminutes = elapsed/1000/60
        if(exception) {log.warn "$windows still open! EMERGENCY CLOSING WILL BE ATTEMPTED"}


        //(inside > desired + (swing +1) && openSinceLong) -> give it a chance to cool down the place
        boolean needToClose  = (inside > desired + (swing * 2) && openSinceLong) || inside < desired - swing || !outsideWithinRange || insideTempIsHopeLess 
        boolean needToOpen = inside > desired + swing && outsideWithinRange && !needToClose  // too hot inside + withinrange (acounting for humidity) and no discrepency

        if(INpwSavingMode)
        {
            outsideWithinRange = outsideTemperature < criticalhot && outsideTemperature > criticalcold
            needToOpen = inside < criticalhot && inside > criticalcold && humidity <= 70 // windows must not open in saving mode if hum is too high to protect electronics 
        }

        logging """<div style=\"width:102%;background-color:green;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">
**********************WINDOWS************************
inWindowsModes = $inWindowsModes
$windows ${!contactCapable ? "${(windows.size() > 1) ? "have":"has"} contact capability" : "${(windows.size() > 1) ? "don't have":"doesn't have"} contact capability"}
closed: ${windows.findAll{it?.currentValue("contact") == "closed"}}
Open: ${windows.findAll{it?.currentValue("contact") == "open"}}
atomicState.openByApp = $atomicState.openByApp
atomicState.closedByApp = $atomicState.closedByApp
withinRange (stritcly): $withinRange
outsideWithinRange = $outsideWithinRange [range: $outsidetempwindowsL <> $outsidetempwindowsH]
insideTempHasIncreased = $insideTempHasIncreased
outsideTempHasDecreased = $outsideTempHasDecreased
atomicState.outsideTempAtTimeOfOpening = $atomicState.outsideTempAtTimeOfOpening
atomicState.insideTempAtTimeOfOpening = $atomicState.insideTempAtTimeOfOpening
insideTempIsHopeLess = $insideTempIsHopeLess ${insideTempIsHopeLess ? "temp went from: $atomicState.outsideTempAtTimeOfOpening to $inside" : ""}
amplThreshold = $amplThreshold
needToOpen = $needToOpen
needToClose = $needToClose
someAreOff = $someAreOff
someAreOpen = $someAreOpen
last time windows were OPEN = ${lastOpeningTime < 2 ? "less than 1 minute ago" : (lastOpeningTime < 60 ? "${lastOpeningTime} minutes ago" : (lastOpeningTime < 60*2 ? "${(lastOpeningTime/60).round(2)} hour ago" : "${(lastOpeningTime/60).round(2)} hours ago"))}
last time windows were CLOSED = ${lastClosingTime < 2 ? "less than 1 minute ago" : (lastClosingTime < 60 ? "${lastClosingTime} minutes ago" : (lastClosingTime < 60*2 ? "${(lastClosingTime/60).round(2)} hour ago" : "${(lastClosingTime/60).round(2)} hours ago"))}
humThres = ${humThres}
humidity = ${humidity}%
tooHumid = $tooHumid
openMore = $openMore
atomicState.widerOpeningDone = $atomicState.widerOpeningDone
${needToClose ? "CLOSING WINDOWS BECAUSE: ${(insideTempHasIncreased && openSinceLong ? "insideTempHasIncreased && openSinceLong" : ((inside < desired - swing) ? "inside < desired - $swing" : (!outsideWithinRange ? "!outsideWithinRange" : (insideTempIsHopeLess ? "insideTempIsHopeLess" : (!someAreOpen ? "Already closed" : "UNKNOWN!")))))}":""}
*****************************************************
</div>
"""
        //atomicState.closedByApp = true

        if(inWindowsModes){

            def time = getWindowsTimeOfOperation(outsideTemperature)

            if(needToOpen) // outsideWithinRange and humidity level are accounted for in needToOpen boolean, unless in power saving mode
            {
                descriptiontext "using $windows INSTEAD OF AC"

                if(someAreOff || openMore)
                {
                    if(openMore) {
                        atomicState.widerOpeningDone = true
                        unschedule(stop)
                    }
                    if(atomicState.closedByApp || openMore)
                    {
                        def message = "opening $windows"
                        windows.on()
                        need0 = "off"
                        need1 = "off"
                        if(!openMore)
                        {
                            atomicState.lastOpeningTime = now()
                            atomicState.outsideTempAtTimeOfOpening = outsideTemperature
                            atomicState.insideTempAtTimeOfOpening = inside
                        }
                        atomicState.openByApp = true
                        atomicState.closedByApp = false

                        if(operationTime && !openMore) // if openMore then open in full
                        {
                            runIn(time, stop)
                            message += " for a duration of $time seconds"
                        }
                        log.warn message

                    }
                    else
                    {
                        descriptiontext "$windows were not closed by this app"
                    }

                }
                else
                {
                    descriptiontext "$windows already open"
                }
            }
            else if(someAreOpen)
            {
                if((atomicState.openByApp && needToClose) || exception)
                {
                    log.warn "closing $windows"
                    unschedule(stop)
                    atomicState.lastClosingTime = now() 
                    atomicState.widerOpeningDone = false // simple value reset
                    windows.off()
                    atomicState.openByApp = false
                    atomicState.closedByApp = true
                }
                else if(!atomicState.openByApp && needToClose)
                {
                    descriptiontext "$windows were not open by this app"
                }
                else
                {
                    descriptiontext "$windows may close soon"
                }

            }


        }
        else if(windows && !inWindowsModes)
        {
            logging "outside of windows modes"
            if(someAreOpen && atomicState.openByApp && (inside > desired + 2 || inside < desired - 2 ))
            {
                windows.off()
            }
        }
        else if(windows && bedSensorContactClosed)
        {
            logging "no windows management due to $bedSensorContact"
        }

    }
    else if(bedSensorContactClosed)
    {
        log.warn "<div style=\"width:102%;background-color:grey;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">Bed Sensor mode is active</div>"
    }

    need = [need0, need1]

    logging"""<div style=\"width:102%;background-color:#1C2BB7;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">
--------------NEED---------------------
inWindowsModes = $inWindowsModes
power saving management= ${powersavingmode ? "$powersavingmode INpwSavingMode = $INpwSavingMode":"option not selected by user"}
amplitude = $amplitude
amplitudeTooHigh = $amplitudeTooHigh

humidity = ${humidity}%
insideHum = ${insideHum}%

outside = $outsideTemperature
inside = $inside
desired = $desired

swing = $swing
coolswing = $coolswing

inside > coolswing = ${inside > coolswing}
inside > desired = ${inside > desired}
inside < desired = ${inside < desired}

bedSensorContactClosed = $bedSensorContactClosed
contactClosed = $contactClosed
outsideThres = $outsideThres
outsideTemperature > desired = ${outsideTemperature > desired}
outsideTemperature < desired = ${outsideTemperature < desired}
outsideTemperature > outsideThres = ${outsideTemperature > outsideThres}
outsideTemperature < outsideThres = ${outsideTemperature < outsideThres}

needCool = $needCool
needHeat = $needHeat (needHeat supercedes needCool) 

final NEED value = $need
---------------------------------------
</div>
"""
    return need

}
def getWindowsTimeOfOperation(outsideTemperature){

    def max = maxDuration ? maxDuration : 2000

    def y = null // value to find
    def x = outsideTemperature // current temperature outside
    def ya = windowsDuration ? windowsDuration : 10 // minimal duration // coressponding duration for when outside temperature = xa
    def xa = outsidetempwindowsL // minimal operation temperature
    def m = 0.9 // slope / coef

    y = m*(x-xa)+ya // solving y-ya = m*(x-xa)
    y = y < max ? y : max

    logging "linear result for windows duration = ${y.toInteger()} seconds"
    return y.toInteger()
}
def getInsideTemp(){

    def inside = thermostat?.currentValue("temperature") 

    if(doorsManagement && doorsContactsAreOpen() && doorSetOfSensors && useDifferentSetOfSensors)
    {
        def sum = 0
        int i = 0
        int s = doorSetOfSensors.size()
        for(s != 0; i<s;i++)
        {
            def val = doorSetOfSensors[i]?.currentValue("temperature")
            descriptiontext "**${doorSetOfSensors[i]} temperature is: $val"
            sum += val
        }

        inside = sum/s
    }
    else if(sensor)
    {
        def sum = 0
        int i = 0
        int s = sensor.size()
        for(s != 0; i<s;i++)
        {
            def val = sensor[i]?.currentValue("temperature")
            descriptiontext "--${sensor[i]} temperature is: $val"
            sum += val
        }

        inside = sum/s
    }
    descriptiontext "average temperature in this room is: $inside"
    inside = inside.toDouble()
    inside = inside.round(2)
    atomicState.inside = inside
    return inside
}
def getOutsideThershold(){

    // define the outside temperature as of which heating or cooling are respectively required 
    // modulated with outside humidity 

    def humidity = outsideTemp?.currentValue("humidity") 
    humidity = humidity != null ? humidity : 50 // prevents error from recently installed thermostats
    if(humidity == null){
        def message = """$outsideTemp is not returning any humdity value - it may be because it was just included; if so, this will resolve ont its own.
If this message still shows within an hour, check your thermostat configuration..."""
        log.warn """<div style=\"width:102%;background-color:red;color:white;padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">$message</div>"""
    }
    def outsideTemperature = outsideTemp?.currentValue("temperature")

    // the higher the humidity, the lower the threshold so cooling can happen 
    def y = null // value to find
    def x = humidity 
    def ya = 60 // coressponding outside temperature value for when humidity = xa 
    def xa = 60 // humidity level
    def m = -0.1 // slope / coef

    y = m*(x-xa)+ya // solving y-ya = m*(x-xa)
    //log.warn "y = $y"
    def result = y > 68 ? 68 : (y < 55 ? 55 : y) // max and min

    descriptiontext "cool/heat decision result = ${y != result ? "$result (coorected from y=$y)" : "$result"} (humidity being ${humidity < 40 ? "low" : "${humidity}%"})"
    return y


}
def getHumidityThreshold(){ // must be called only upon windows opening decision
    def humidity = outsideTemp?.currentValue("humidity") 
    humidity = humidity != null ? humidity : 50
    def outsideTemperature = outsideTemp?.currentValue("temperature")

    // we want to set a humidity threshold depending on outside temperature
    // humidity of 98, even an outside temp of 70 will feel too warm so we don't open the windows
    // but humidity of 98 at 60F, it's ok to use outside air to cool down the house

    def y = null // value to find
    def x = outsideTemperature 
    def ya = 90 // coressponding humidity threshold for when humidity = xa
    def xa = 60
    def m = -0.9 // slope / coef

    y = m*(x-xa)+ya // solving y-ya = m*(x-xa)
    // y = y >= 78 ? 

    return y

}
def Poll(){


    boolean thermPoll = thermostat.hasCommand("poll")
    boolean thermRefresh = thermostat.hasCommand("refresh") 


    boolean outsidePoll = outsideTemp.hasCommand("poll")
    boolean outsideRefresh = outsideTemp.hasCommand("refresh")
    boolean override = atomicState.override

    if(thermRefresh){
        thermostat.refresh()
        descriptiontext("refreshing $thermostat")
    }
    if(thermPoll){
        thermostat.poll()
        descriptiontext("polling $thermostat")
    }
    if(outsideRefresh){
        outsideTemp.refresh()
        descriptiontext("refreshing $outsideTemp")
    }
    if(outsidePoll){
        outsideTemp.poll()
        descriptiontext("polling $outsideTemp")
    }

    boolean heaterPoll = heater?.hasCommand("poll")
    boolean heaterRefresh = heater?.hasCommand("refresh") 

    if(heaterRefresh){
        heater.refresh()
        descriptiontext("refreshing $heater")
    }
    if(heaterPoll){
        heater.poll()
        descriptiontext("polling $heater")
    }

    if(sensor)
    {
        boolean sensorPoll = sensor.findAll{it.hasCommand("poll")}.size() == sensor.size()
        boolean sensorRefresh = sensor.findAll{it.hasCommand("refresh")}.size() == sensor.size()

        if(sensorRefresh){
            int i = 0
            int s = sensor.size()
            for(s!=0;i<s;i++)
            {
                sensor[i].refresh()
                descriptiontext("refreshing ${sensor[i]}")
            }
        }
        if(sensorPoll){
            int i = 0
            int s = sensor.size()
            for(s!=0;i<s;i++)
            {
                sensor[i].poll()
                descriptiontext("polling ${sensor[i]}")
            }
        }
    }
    boolean pwPoll = pw?.hasCommand("poll")
    boolean pwRefresh = pw?.hasCommand("refresh") 

    if(pwRefresh){
        pw.refresh()
        descriptiontext("refreshing $pw")
    }
    if(pwPoll){
        sensor.poll()
        descriptiontext("polling $pw")
    }

}
/************************************************BOOLEANS*********************************************************/
boolean contactsAreOpen(){
    boolean Open = false
    def listOpen = []
    if(contact)
    {
        listOpen = contact?.findAll{it?.currentValue("contact") == "open"}
        Open = listOpen.size() > 0
    }

    logging """$contact open ?: ${listOpen}"""
    return Open
}
boolean bedSensorIsClosed(){
    boolean result = false
    //log.warn "useAbedSensor = $useAbedSensor"
    if(useAbedSensor)
    {
        if(bedSensorType == "contact")
        {
            def Dtime = 60000
            int s = bedSensorContact.size() 
            int i = 0
            def thisDeviceEvents = []
            int events = 0
            def findClosed = bedSensorContact.findAll{it?.currentValue("contact") == "closed"}
            boolean currentlyClosed = findClosed.size() != 0
            //log.warn "AnyCurrentlyActive: $AnyCurrentlyActive"
            if(currentlyClosed) { 
                return true 
            }
            else 
            {
                for(s != 0; i < s; i++) // collect active events
                { 
                    thisDeviceEvents = bedSensorContact[i].eventsSince(new Date(now() - Dtime)).findAll{it.value in ["closed", "open"]} // collect ALL motion events for each sensor separately
                    events += thisDeviceEvents.size() 
                }
                descriptiontext("$bedSensorContact ${s>1? "were":"was"} closed $events times in the last ${Dtime/1000} seconds")
            }

            result = events > 0
            logging("$bedSensorContact closed ?: $result")
        }
        else if(bedSensorType == "button")
        {
            def Dtime = 60000
            int s = bedSensorButton.size() 
            int i = 0
            def thisDeviceEvents = []
            int events = 0

            log.debug "******${bedSensorButton[i]} state = ${bedSensorButton[i]?.currentValue("pushed")}"

            for(s != 0; i < s; i++) // collect button events
            { 
                thisDeviceEvents = bedSensorButton[i].eventsSince(new Date(now() - Dtime)).findAll{it.name in ["held", "pushed"]} // collect ALL button events for each sensor separately
                events += thisDeviceEvents.size() 
            }
            descriptiontext("$bedSensorButton ${s>1? "were":"was"} held or pushed $events times in the last ${Dtime/1000} seconds")

            result = events > 0
            logging("$bedSensorButton closed ?: $result")
        }
    }
    return result
}
boolean doorsContactsAreOpen(){
    boolean Open = false
    def listOpen = []
    if(doorsContacts)
    {
        listOpen = doorsContacts?.findAll{it?.currentValue("contact") == "open"}
        Open = listOpen.size() > 0
    }

    logging """$doorsContacts open ?: ${listOpen}"""
    return Open
}
boolean Active(){
    boolean result = true // default is true  always return Active = true when no sensor is selected by the user


    if(motionSensors)
    {
        long Dtime = noMotionTime * 1000 * 60
        int s = motionSensors.size() 
        int i = 0
        def thisDeviceEvents = []
        int events = 0
        boolean inMotionMode = location.mode in motionmodes
        logging "inMotionMode = $inMotionMode"

        if(inMotionMode)
        {
            for(s != 0; i < s; i++) // collect active events
            { 
                def device = motionSensors[i]                
                thisDeviceEvents = device.eventsSince(new Date(now() - Dtime)).findAll{it.value == "active"} // collect motion events for each sensor separately
                logging "Collected ${thisDeviceEvents.size()} evts for $device"
                events += thisDeviceEvents.size() 
            }
            descriptiontext "$events active events in the last ${noMotionTime} minutes"
            result = events > 0 
        }
        else 
        {
            logging("motion returns true because outside of motion modes")
        }

    }
    else 
    {
        logging("user did not select any motion sensor")
    }
    return result
}
/************************************************OTHER*********************************************************/
def stop(){

    if(customCommand)
    {
        log.warn "$windows $customCommand"
        windows.stop() //"${customCommand}"
    }
    else
    {
        log.warn "$windows off"
        windows.off()
    }
}
def logging(message){
    if(enabledebug)
    {
        log.debug message
    }
    if(atomicState.EnableDebugTime == null) atomicState.EnableDebugTime = now()
}
def descriptiontext(message){
    if(description)
    {
        log.info message
    }
}
def disablelogging(){
    log.warn "debug logging disabled..."
    app.updateSetting("enabledebug",[value:"false",type:"bool"])
}
def formatTitle(title, textColor, bckgColor)
{
    return  "<div style=\"width:102%;background-color:${bckgColor};color:${textColor};padding:4px;font-weight: bold;box-shadow: 1px 2px 2px #bababa;margin-left: -10px\">${title}</div>"
}
